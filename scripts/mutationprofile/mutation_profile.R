#!/usr/bin/env Rscript

library(stringr)
library(reshape2)
library(gplots)
library(RColorBrewer)
library(readr)
library(pheatmap)

## Generates mutation profile for set of variants from covsonar.
## Takes input data as obtained by covsonar (each lineage one tsv file) , 
## filters for mutations with at least 75% prevalence in all samples per lineage,
## greps for spike proteins, RBD sites. 
##
### INPUT: 
#### (In1) input data file as tsv as obtained by covsonar 
#### (In2) results directory
#### (In3) prefix for output files
#### (In4) threshold: mutations should be present in at least x% of all samples
#### (In5) date start: date to starting simulations
#### (In6) date end: date to end simulations
### OUTPUT:
#### (Out1) <prefix>_mutations_spike_lists.csv : table with mutated sites for each lineage
#### (Out2) <prefix>_mutations_spike.csv : matrix with mutation profile for each lineage
#### (Out3) <prefix>_RBD_NTD_mutations.csv : table with mutational profile for each lineage.
#### (Out4) <prefix>_RBD_NTD_pseudogroups.csv: table with lineages and grouping based on identical mutational profile in RBD and NTD
#### (Out5) <prefix>_mutations_spikenumber_of_genomes_per_lineage.csv : table with number of genomes per lineage
#### (Out6) <prefix>_positiongroups_RBD_NTD_groups.pdf : Mutation Profile as plot
#### (Out7) <prefix>_positiongroups_RBD_NTD_groups_zoom.pdf : Mutation Profile of predefined lineages.

args = commandArgs(trailingOnly=TRUE)
if (length(args)!=6) {
  stop("Call: Rscript generate_mutation_profile <covsonar data file> <output directory> <prefix> <mutation threshold> <date start> <date end>", call.=FALSE)
} else  {
  input_datafile_covsonar <- args[1]
  outputdir <- args[2]
  output_prefix_for_file <- args[3]
  threshold <- as.numeric(args[4])
  date_start <- args[5]
  date_end <- args[6]
}
#Paper input:
#input_datafile_covsonar <- "DATA/Stichprobe_RKI-JUL21toMay23_merged.tsv"
#outputdir <- "results_mutationprofiles/"
#output_prefix_for_file <- "mutationprofileJul21May23"
#threshold <- 0.75  #mutations should be present in at least 75% of all samples
dir.create(outputdir, showWarnings = FALSE)

## Outputfiles:
outputfile_mutationlist <- paste0(output_prefix_for_file,"_mutations_spike_lists.csv")
outputfile_mutationprofile <- paste0(output_prefix_for_file,"_mutations_spike.csv")
outputfile_mutationprofile_mutations <- paste0(output_prefix_for_file,"_RBD_NTD_mutations.csv")
outputfile_mutationprofile_plot <- paste0(output_prefix_for_file,"_positiongroups_RBD_NTD_groups.pdf")
outputfile_mutationprofile_groups <- paste0(output_prefix_for_file,"_RBD_NTD_pseudogroups.csv")


zoom_in_lineages <- c("XBB.1.5", "XBT", "XBK.1", "XBK")

######## CONSTANT DEFINTIONS:
## spike protein positions (NTD and RBD):
NTD_position_start <- 13
NTD_position_end <- 317
RBD_position_start <- 318
RBD_position_end <- 541

######################################### DATA PROCESSING 1: mutation profile

#### READ DATA and FILTER for mutations with at least 75% prevalence in all samples per lineage
D <- read.csv(input_datafile_covsonar, sep = "\t")
# Produce demo file
#v1 <- sort(sample(11:length(D$date)-10, 200, replace=F))
#t_keep <- c(1:10, v1)
#t_keep <- c(t_keep, (length(D$date)-9):length(D$date))
#print(length(t_keep))
#Dmock <- D[t_keep,]
#write.table(Dmock, file='covsonar_mock.tsv', quote=FALSE, sep='\t', col.names = NA)

### filter data to start and end date
dates <- D$date
u_dates <- unique(dates)
id_dates <- 1:length(u_dates)
between_dates <- subset(u_dates, (id_dates >= match(date_start, u_dates))&(id_dates <= match(date_end, u_dates)))
to_keep <- c()
for (i in 1:length(dates)){
  if (dates[i] %in% between_dates){
    to_keep <- append(to_keep, i)
  }
}
D <- D[to_keep,]
sprintf("Timeframe of extracted mutation profiles %s to %s", unique(D$date)[1], unique(D$date)[length(unique(D$date))])

### filter mutations 
lineages <- sort(unique(D$lineage))
number_lineages <- length(lineages)

mutationprofiles_l <- list()
lineages_l <- c()
lineages_without_mutations <- c()
number_genomes_per_lineage <- c()
for (i in 1:number_lineages){
  D_lineagename <- lineages[i]
  Dlin <- D[which(D$lineage == D_lineagename),]
  D_N <- nrow(Dlin)
  aaprofile <- Dlin$aa_profile
  if (length(which(!is.na(aaprofile))) > 0){
    aaprofile_l <- list()
    for (j in 1:D_N){
      aaprofile_l[j] <- strsplit(aaprofile[j]," ")
    }
    count <- table(unlist(lapply(aaprofile_l, unique)))
    count_df <- as.data.frame(count)
    count_df <- count_df[order(count_df$Freq, decreasing = TRUE),]
    N <- D_N*threshold
    D_mutationprofile <- count_df$Var1[which(count_df$Freq >= N)]
    mutationprofiles_l[i] <- list(D_mutationprofile)
    lineages_l = c(lineages_l, D_lineagename)
  }
  else{
    lineages_without_mutations <- c(lineages_without_mutations, D_lineagename) 
  }
  number_genomes_per_lineage <- c(number_genomes_per_lineage, D_N)
}
number_lineages <- number_lineages-length(lineages_without_mutations)
number_genomes_per_lineage <- cbind(lineages_l, number_genomes_per_lineage)
write.csv(number_genomes_per_lineage, file=paste0(outputdir,"/",stringr::str_replace(outputfile_mutationprofile, ".csv","number_of_genomes_per_lineage.csv")), quote = FALSE, row.names = FALSE)
print(paste("Number of lineages in this dataset:",number_lineages))
rm(Dlin); rm(D_lineagename); rm(D_N);rm(aaprofile);rm(count);rm(count_df);rm(N);rm(D_mutationprofile)

## Grep for only spike ("S:") and RBD (RBDsites) mutations.
mutation_lists <- c()
for (i in 1:number_lineages){
  m1 <- mutationprofiles_l[[i]]
  m1 <- m1[grep("S:",m1)]
  m1 <- gsub("S:","",m1)
  if (length(grep(":",m1) > 0)) {m1 <- m1[-grep(":",m1)] } #remove any deletions etc. keep only mutations
  m1 <- sort(m1)
  if (length(mutation_lists) == 0){
    mutation_lists <- cbind(lineages_l[i], paste(m1, collapse = "/"))
  }else{
    mutation_lists <- rbind(mutation_lists, 
                           cbind(lineages_l[i], paste(m1, collapse = "/")))
  }
}
colnames(mutation_lists) <- c("lineage", "mutated_sites_RBD")
mutation_lists <- as.data.frame(mutation_lists)
rm(m1)

## store as matrix:
spikemutations_list <- c()
for (i in 1:number_lineages){
  spikemutations_list <- c(spikemutations_list, strsplit(mutation_lists$mutated_sites_RBD[i],"/")[[1]])
}
spikemutations_list <- unique(spikemutations_list)

## Sort according to site:
spikemutations_list_site <- parse_number(spikemutations_list)
ix <- sort(spikemutations_list_site, index.return=TRUE)$ix
spikemutations_list <- spikemutations_list[ix]
rm(ix);rm(spikemutations_list_site)

MP <- as.data.frame(matrix(nrow = number_lineages, ncol = length(spikemutations_list)))
colnames(MP) <- spikemutations_list
rownames(MP) <- lineages_l
for (i in 1:number_lineages){
  m1 <- strsplit(mutation_lists$mutated_sites_RBD[i],"/")[[1]]
  x <- unlist(lapply(m1, function(x) which(colnames(MP) == x)))
  MP[lineages_l[i],x] <- 1
}
rm(m1);rm(x)

## Remove sites with empty entries only:
j <- c()
for (i in 1:ncol(MP)){
  if (length(which(!is.na(MP[,i]))) == 0){
    j <- c(j, i)
  }
}
if(length(j)>0){ 
  MP2 <- MP[,-j]
}else{
  MP2<- MP
}
MP2[is.na(MP2)]<-0
MP2 <- MP2[order(row.names(MP2)), ]
rm(MP)

write.csv(mutation_lists, file=paste0(outputdir,"/",outputfile_mutationlist), quote = FALSE, row.names = FALSE)
write.csv(MP2, file=paste0(outputdir,"/",outputfile_mutationprofile))





######################################### DATA PROCESSING 2: NTD & RBD

## Spike Protein groupings: NTD and RBD
sites <- parse_number(colnames(MP2))
NTD_before_positions <- c(1:(NTD_position_start-1))
NTD_positions <- c(NTD_position_start:NTD_position_end)
RBD_positions <- c(RBD_position_start:RBD_position_end) 
RBD_after_positions <- c((RBD_position_end+1):max(sites)) 

sites_ntd_before <- intersect(sites, NTD_before_positions)
sites_ntd_before_x <- unlist(lapply(sites_ntd_before, function(x) which(sites == x)))
sites_ntd <- intersect(sites, NTD_positions)
sites_ntd_x <- unlist(lapply(sites_ntd, function(x) which(sites == x)))
sites_rbd <- intersect(sites, RBD_positions)
sites_rbd_x <- unlist(lapply(sites_rbd, function(x) which(sites == x)))
sites_rbd_after <- intersect(sites, RBD_after_positions)
sites_rbd_after_x <- unlist(lapply(sites_rbd_after, function(x) which(sites == x)))

mydf <- data.frame(row.names = colnames(MP2), category = c(rep("Before NTD", length(sites_ntd_before_x)), 
                                                           rep("NTD", length(sites_ntd_x)), 
                                                           rep("RBD", length(sites_rbd_x)), 
                                                           rep("after RBD", length(sites_rbd_after_x))))



######################################### DATA PROCESSING 3: Lineage Grouping

## Lineages are called identical if NTD and RBD regions are equal:
ix <- c(which(mydf=="NTD"), which(mydf=="RBD"))
MP3 <- MP2[,ix]
mydf3 <- as.data.frame(mydf[ix,]); colnames(mydf3) <- "category"; rownames(mydf3) <- rownames(mydf)[ix]
rm(ix)

## Some stats:
print(paste("Number of mutations in the spike protein for all given lineages:", ncol(MP2)))
print(paste("Number of mutations in the NTD region of the spike for all given lineages:", length(which(mydf=="NTD"))))
print(paste("Number of mutations in the RBD region of the spike for all given lineages:",length(which(mydf=="RBD"))))


## Spike-pseudogrouping: find duplicated lineages based on equal profile of NTD & RBD:
MP_l <- c()
for (i in 1:nrow(MP3)){
  MP_l <- c(MP_l, paste(colnames(MP3)[which(MP3[i,]==1)],collapse = "/"))
}
MP_l <- data.frame(cbind(rownames(MP3),MP_l))
colnames(MP_l) <- c("lineage","RBD_NTD_mutations")
write.csv(MP_l, file=paste0(outputdir,"/",outputfile_mutationprofile_mutations), row.names = FALSE, quote = FALSE)

psgroups <- c()
for (i in 1:nrow(MP_l)){
  #l <- MP_l$lineage[i]
  members <- MP_l$lineage[which(MP_l$RBD_NTD_mutations == MP_l$RBD_NTD_mutations[i])]
  psgroups <- c(psgroups, paste(members,collapse = "/"))
}
psgroups <- data.frame(cbind(MP_l$lineage,psgroups))
colnames(psgroups) <- c("lineage","group")

psgroups2 <- psgroups[!duplicated(psgroups$group),]
write.csv(psgroups2, file=paste0(outputdir,"/",outputfile_mutationprofile_groups), row.names = FALSE, quote = FALSE)

print(paste("Number of Spike-Pseudogroups found:", length(grep("/",psgroups2$group))))
print(paste("Number of individual lineages:",nrow(psgroups2) - length(grep("/",psgroups2$group))))


####################### Plotting:

# Limit the numer of lineages in the plotting: at least 100 genomes must be present for being plotted:
min_number_genomes_for_plotting <- 100
number_genomes_per_lineage <- data.frame(number_genomes_per_lineage)
colnames(number_genomes_per_lineage) <- c("lineage","N")
number_genomes_per_lineage$N <- as.numeric(number_genomes_per_lineage$N )
lineages_above_genome_threshold <- number_genomes_per_lineage$lineage[which(number_genomes_per_lineage$N > min_number_genomes_for_plotting)]

# Highlight Spike-Pseudogroups with "*" behind name to distinguish from individual lineages that do not belong to any group (or represent an own group, respectivly)
psgr <- c()
for (i in 1:nrow(psgroups2)){
  if (psgroups2$group[i] != psgroups2$lineage[i]){
    psgr <- c(psgr,psgroups2$lineage[i])
  }
}
MP3_red <- MP3[unlist(lapply(lineages_above_genome_threshold, function(x) which(rownames(MP3) == x))),]
MP4_unique <- MP3_red[!duplicated(MP3_red),]
x <- unlist(lapply(psgr, function(x) which(rownames(MP4_unique) == x)))
rownames(MP4_unique)[x] <- paste0(rownames(MP4_unique)[x],"*")
rm(x)

#remove empty mutational sites:
x <- which(apply(MP4_unique,2,sum)>0)
MP4_unique <- MP4_unique[,x]
mydf3 <- as.data.frame(mydf3[x,]); colnames(mydf3) <- "category"; rownames(mydf3) <- colnames(MP4_unique)
rm(x)
print(paste("Number of lineages / Spike-pseudogroups found with > 1000 genomes available in the dataset that are plotted as a heatmap:", nrow(MP4_unique)))

if (length(MP4_unique)>=2){
  pdf(paste0(outputdir,"/",outputfile_mutationprofile_plot), height = 15, width = 15)
  pheatmap(as.matrix(MP4_unique), main = paste("Spike Mutation Profile (NTD / RBD)"), col=c("white","red"),
           cluster_cols = F, cluster_rows = T,
           fontsize_col = 10,fontsize_row = 10,
           legend = FALSE,
           annotation_col = mydf3)
  dev.off()
  }


### Zooming in for a predefined set of lineages:
MP2_zoom <- MP2[unlist(lapply(zoom_in_lineages, function(x) which(rownames(MP2) == x))),]
#keep only those sites with at least one mutations among the lineages
MP2_zoom <- MP2_zoom[,which(apply(MP2_zoom,2,sum)>0)] 
#keep only RBD and NTD regions:
MP2_zoom <- MP2_zoom[,unlist(lapply(intersect(rownames(mydf3),colnames(MP2_zoom)), 
                                    function(x) which(colnames(MP2_zoom) == x)))]

if (length(MP2_zoom)>=2){
  pdf(paste0(outputdir,"/",stringr::str_replace(outputfile_mutationprofile_plot,".pdf","_zoom.pdf")),height = 3, width = 10)
  pheatmap(as.matrix(MP2_zoom), 
           main = paste("Zoom Mutation Profile of",paste(zoom_in_lineages,collapse = ",")), 
           col=c("white","red"),
           cluster_cols = F, cluster_rows = T,
           fontsize_col = 10,fontsize_row = 10,
           legend = FALSE,
           annotation_col = mydf3)
  dev.off()
 }